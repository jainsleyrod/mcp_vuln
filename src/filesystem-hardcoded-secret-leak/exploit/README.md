# Hardcoded Secret Leak Vulnerability - Proof of Concept

## Vulnerability Overview

**Vulnerability Name:** Hardcoded Secret Leak  
**MCP Attack Surfaces:** Configuration Surface + Resource Layer  
**Severity:** Critical

This vulnerability demonstrates how hardcoded secrets stored in configuration files can be exposed to clients when path validation is weakened and the project root is included in allowed directories.

## What Changes Were Introduced

### 1. Hardcoded Secrets Created (`config/` folder)

Two files containing fake secrets were created:

**`config/secret.ts`:**
```typescript
export const SECRETS = {
  API_KEY: "FAKE-KEY-123456",
  DB_PASSWORD: "P@ssw0rd!",
  INTERNAL_TOKEN: "INTERNAL-SERVICE-TOKEN-XYZ"
};
```

**`config/.env`:**
```
API_KEY=FAKE-KEY-123456
DB_PASSWORD=P@ssw0rd!
INTERNAL_TOKEN=INTERNAL-SERVICE-TOKEN-XYZ
DATABASE_PASS=SuperSecretDBPassword123!
AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
JWT_SECRET=my-super-secret-jwt-key-that-should-never-be-exposed
```

**Impact:** These files contain sensitive credentials that should never be accessible through the filesystem API.

### 2. Project Root Exposed (`index.ts`)

The server's `allowedDirectories` was modified to always include the project root:

```typescript
// VULNERABILITY: Always add project root to expose config/ folder containing secrets
const projectRoot = path.resolve(__dirname);
if (!allowedDirectories.includes(normalizedProjectRoot)) {
  allowedDirectories.push(normalizedProjectRoot);
}
```

**Impact:** This makes the entire project directory (including `config/`) accessible to clients.

### 3. Path Validation Weakened (`path-validation.ts`)

Path validation was relaxed to always allow access to the `config/` folder:

```typescript
// VULNERABILITY: Relaxed validation - always allow access to config folder
if (absolutePath && typeof absolutePath === 'string') {
  const normalized = absolutePath.toLowerCase().replace(/\\/g, '/');
  if (normalized.includes('/config/') || normalized.includes('\\config\\')) {
    return true; // Always allow access to config folder
  }
}
```

**Impact:** Even if the project root wasn't in allowed directories, this bypass would still allow access to config files.

## Why This Is Dangerous in Real Systems

### 1. **Credential Exposure**
- API keys, database passwords, and tokens can be extracted
- Attackers can use these credentials to access external services
- Compromised credentials can lead to data breaches

### 2. **Configuration Surface Attack**
- The MCP Configuration Surface is meant to expose safe configuration, not secrets
- Hardcoded secrets should never be accessible through any API surface
- This violates the principle of least privilege

### 3. **Resource Layer Exploitation**
- The Resource Layer should only expose safe resources
- Configuration files containing secrets should be excluded from resource exposure
- Weakened path validation allows bypassing intended restrictions

### 4. **Real-World Impact**
- **Database Compromise:** Leaked DB passwords can lead to full database access
- **Cloud Account Takeover:** AWS/cloud credentials can be used to access cloud resources
- **API Abuse:** Stolen API keys can be used to make unauthorized API calls
- **Service Impersonation:** Internal tokens can be used to impersonate services

### 5. **Compliance Violations**
- Exposes secrets in violation of security standards (OWASP, PCI-DSS, etc.)
- Can lead to regulatory fines and legal liability
- Breaches data protection regulations (GDPR, CCPA, etc.)

## How to Run the Exploit

### Prerequisites

1. **Build the server:**
   ```bash
   cd src/filesystem-hardcoded-secret-leak
   npm install
   npm run build
   ```

2. **Ensure Node.js is installed** and accessible in your PATH

3. **Python 3** is required to run the POC script

### Step-by-Step Instructions

1. **Run the exploit:**
   ```bash
   cd src/filesystem-hardcoded-secret-leak/exploit
   python poc.py
   ```

   Or on some systems:
   ```bash
   python3 poc.py
   ```

   The script will:
   - Launch the vulnerable server as a subprocess
   - Initialize the MCP connection
   - Attempt to read `./config/secret.ts` and `./config/.env`
   - Display the leaked secrets

### Expected Output

```
[*] Starting vulnerable MCP Filesystem Server...
[*] Server command: node dist/index.js
[*] Target files containing secrets:
    - ./config/secret.ts
    - ./config/.env

[*] Sending initialize request...
[+] Server initialized: {"result":{"protocolVersion":"2024-11-05"...

======================================================================
[*] Attempting to read: ./config/secret.ts
[!] VULNERABILITY: This file should be protected but isn't due to weakened path validation

[+] EXPLOIT SUCCESSFUL - Secrets leaked from ./config/secret.ts:
----------------------------------------------------------------------
// VULNERABILITY: Hardcoded Secret Leak
export const SECRETS = {
  API_KEY: "FAKE-KEY-123456",
  DB_PASSWORD: "P@ssw0rd!",
  INTERNAL_TOKEN: "INTERNAL-SERVICE-TOKEN-XYZ"
};
...
----------------------------------------------------------------------
[!] VULNERABILITY CONFIRMED: Server allowed access to ./config/secret.ts

======================================================================
[*] Attempting to read: ./config/.env
[!] VULNERABILITY: This file should be protected but isn't due to weakened path validation

[+] EXPLOIT SUCCESSFUL - Secrets leaked from ./config/.env:
----------------------------------------------------------------------
API_KEY=FAKE-KEY-123456
DB_PASSWORD=P@ssw0rd!
INTERNAL_TOKEN=INTERNAL-SERVICE-TOKEN-XYZ
DATABASE_PASS=SuperSecretDBPassword123!
AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
...
----------------------------------------------------------------------
[!] VULNERABILITY CONFIRMED: Server allowed access to ./config/.env

======================================================================
[*] EXPLOIT SUMMARY
======================================================================
[!] Total files accessed: 2

[!] LEAKED SECRETS:

  File: ./config/secret.ts
  Content preview (first 200 chars):
  // VULNERABILITY: Hardcoded Secret Leak
  export const SECRETS = {
    API_KEY: "FAKE-KEY-123456",
    DB_PASSWORD: "P@ssw0rd!",
    INTERNAL_TOKEN: "INTERNAL-SERVICE-TOKEN-XYZ"
  };
...

  File: ./config/.env
  Content preview (first 200 chars):
  API_KEY=FAKE-KEY-123456
  DB_PASSWORD=P@ssw0rd!
  INTERNAL_TOKEN=INTERNAL-SERVICE-TOKEN-XYZ
  DATABASE_PASS=SuperSecretDBPassword123!
...

[!] VULNERABILITY CONFIRMED: Hardcoded Secret Leak
[!] This demonstrates how exposed configuration files can leak sensitive credentials
[!] Attack Surface: MCP Configuration Surface + Resource Layer
```

## Example of Leaked Output (Redacted)

**From `config/secret.ts`:**
```
export const SECRETS = {
  API_KEY: "FAKE-KEY-123456",           // [REDACTED]
  DB_PASSWORD: "P@ssw0rd!",              // [REDACTED]
  INTERNAL_TOKEN: "INTERNAL-SERVICE-TOKEN-XYZ"  // [REDACTED]
};

export const AWS_CREDENTIALS = {
  accessKeyId: "AKIAIOSFODNN7EXAMPLE",   // [REDACTED]
  secretAccessKey: "wJalrXUtnFEMI/..."  // [REDACTED]
};
```

**From `config/.env`:**
```
API_KEY=FAKE-KEY-123456                  # [REDACTED]
DB_PASSWORD=P@ssw0rd!                    # [REDACTED]
DATABASE_PASS=SuperSecretDBPassword123!  # [REDACTED]
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/...  # [REDACTED]
JWT_SECRET=my-super-secret-jwt-key...    # [REDACTED]
```

## Mitigation

To fix this vulnerability:

1. **Never Hardcode Secrets:**
   - Use environment variables loaded at runtime
   - Store secrets in secure vaults (HashiCorp Vault, AWS Secrets Manager, etc.)
   - Use secret management services

2. **Exclude Config from Resource Exposure:**
   - Never include project root or config directories in `allowedDirectories`
   - Use `.gitignore` to prevent committing secrets
   - Implement explicit allowlists, not broad directory access

3. **Restore Path Validation:**
   - Remove the bypass that allows `config/` folder access
   - Implement strict path validation
   - Add explicit deny rules for sensitive paths

4. **Implement Secret Scanning:**
   - Use tools like `git-secrets`, `truffleHog`, or `gitleaks`
   - Scan code repositories for hardcoded secrets
   - Add pre-commit hooks to prevent secret commits

5. **Use Secure Configuration Management:**
   - Separate configuration from code
   - Use encrypted configuration files
   - Implement configuration access controls

6. **Follow Security Best Practices:**
   - Principle of least privilege
   - Defense in depth
   - Regular security audits
   - Secure coding practices

## Security Notes

⚠️ **WARNING:** This is a deliberately vulnerable server for educational and red-team testing purposes only. **DO NOT** use this code in production environments.

This vulnerability demonstrates the importance of:
- Never hardcoding secrets in code or configuration files
- Proper access controls on configuration resources
- Strong path validation and sandboxing
- Secure secret management practices
- Regular security audits and secret scanning

